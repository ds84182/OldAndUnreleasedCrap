dofile("DSOS/kernel/LiL")

--This is the kernel entrypoint, this is where we will set up crap.
--DSOS will not support regular CC code, and I may not make an emulator for it.

--System functions
function checkType(val,types)
	if type(types) == "string" then
		return type(val) == types
	elseif type(types) == "table" then
		for i, v in pairs(types) do
			if v == type(val) then
				return true
			end
		end
	end
	return false
end

_G.file = {}
file = _G.file
do
	--The file api will sport some stuff to easily open, close, read, and write to files
	--This replaces fs.*
	local handles = {}
	local rfs = fs
	fs = nil
	local fs = rfs
	rfs = nil
	
	function file.exists(path)
		return fs.exists(path)
	end
	
	function file.list(path)
		return fs.list(path)
	end
	
	file.combine = fs.combine
	
	function file.recursiveList(path)
		local files = fs.list(path)
		local n = {}
		for i,v in pairs(files) do
			if fs.isDir(fs.combine(path,v)) then
				n[i] = file.recursiveList(fs.combine(path,v))
			else
				n[i] = v
			end
		end
		return n
	end
	
	function file.append(path,str)
		local fh = fs.open(path,"wa")
		fh.write(str)
		fh.close()
	end
	
	function file.write(path,str)
		local fh = fs.open(path,"w")
		fh.write(str)
		fh.close()
	end
	
	function file.prepend(path,str)
		file.write(path,str..file.read(path))
	end
	
	function file.read(path)
		local fh = fs.open(path,"r")
		local r = fh.readAll()
		fh.close()
		return r
	end
end

--Start multitasking
local proc = {} --A list of processes (lua interpreters)

local MAIN_CODE = 
[[
	term.clear()
	term.setCursorPos(1,1)
	loadstring(file.read("DSOS/bin/shell"),"shell")()
]]

proc[1] = {
	LiL.interpret({
		LiL.parseFile("DSOS/emu/bios"),
		LiL.parse(LiL.tokenize(MAIN_CODE))
	}),
	{}
}

local numS = 0
local evtQ = {}
while true do
	local rem = {}
	for _, event in pairs(evtQ) do
		for i, v in pairs(proc) do
			if (v[2] and (v[2][1] == event[1] or v[2][1] == nil)) or not v[2] then
				local status, err, t = pcall(v[1].run,unpack(event))
				v[2] = t
				numS = numS+1
				if status and err == false then
					table.insert(rem,i)
				else
					if not status and type(err) == "table" then
						printError(err[1], ": ", err[2])
					elseif not status then
						printError(tostring(err))
					end
				end
			else
				--print("Not "..tostring(ret[1]).." but "..tostring(v[2][1]))
			end
		end
		for i=1, #rem do
			proc[rem[i]] = nil
		end
	end
	evtQ = {}
	local tim = os.startTimer(0)
	while true do
		local ret = {os.pullEventRaw()}
		table.insert(evtQ,ret)
		if ret[1] == "timer" and ret[2] == tim then
			ret[1] = "inst"
			break
		end
	end
	if #proc == 0 then
		break
	end
end

print("Main loop ended")
print("Closing filesystem handles...")
print("Unmounting mounted vfses")
print("end")
