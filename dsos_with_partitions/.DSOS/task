--scheduler--
local task = {}
local args = {...}
local pipe = args[1]
local sch = {}
local nullsch = {}
local tasks = {}
local capp
local ev = {}
local function render()
	for i,v in pairs(pipe.getAllPipes()) do
		pipe.draw(i)
	end
	pipe.afterDraw()
end
function task.add(env, func, name, args)
	local id = 1
	while tasks[id] ~= nil do id = id+1 end
	setfenv(func,env)
	tasks[id] = {env=env,c=coroutine.create(func),args=args,name=name,fr=true,suspend=false}
	table.insert(nullsch, id)
	return id, tasks[id]
end

function task.kill(id)
	tasks[id] = nil
end

function task.get(id)
	return tasks[id]
end

function task.tlist()
	return tasks
end

function task.capp()
	return capp
end

function task.update()
	--First, do all processes that don't require a event--
	local tmp = nullsch
	nullsch = {}
	for i,v in pairs(tmp) do
		local p = tasks[v]
		if p ~= nil then
			if coroutine.status(p.c) ~= "dead" then
				local e = p.args or ev
				capp = p
				local ret = {coroutine.resume(p.c,unpack(e))}
				capp = nil
				if p.args ~= nil then p.args = nil end
				if ret[1] then
					table.remove(ret,1)
					local e = ret[1]
					if e ~= nil then
						sch[e] = sch[e] or {}
						table.insert(sch[e], v)
					else
						table.insert(nullsch, v)
					end
				else
					error(p.name..":"..ret[2])
				end
			else
				task.kill(v)
			end
		end
		if i%4==0 then
			render()
		end
	end
	if ev[1] ~= nil then
		sch[ev[1]] = sch[ev[1]] or {}
		local tmp = sch[ev[1]]
		sch[ev[1]] = {}
		for i,v in pairs(tmp) do
			local p = tasks[v]
			if p ~= nil then
				if coroutine.status(p.c) ~= "dead" then
					local e = ev
					capp = p
					local ret = {coroutine.resume(p.c,unpack(e))}
					capp = nil
					if ret[1] then
						table.remove(ret,1)
						local e = ret[1]
						if e ~= nil then
							sch[e] = sch[e] or {}
							table.insert(sch[e], v)
						else
							table.insert(nullsch, v)
						end
					else
						error(p.name..":"..ret[2])
					end
				else
					task.kill(v)
				end
			end
			if i%4==0 then
				render()
			end
		end
	end
	render()
	ev = {coroutine.yield()}
end

return task