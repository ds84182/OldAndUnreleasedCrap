local version = 020.2
colors = {
white = 1,
orange = 2,
magenta = 4,
lightBlue = 8,
yellow = 16,
lime = 32,
pink = 64,
gray = 128,
lightGray = 256,
cyan = 512,
purple = 1024,
blue = 2048,
brown = 4096,
green = 8192,
red = 16384,
black = 32768
}
os.pullEvent = coroutine.yield
os.pullEventRaw = os.pullEvent
function write( sText )
	local w,h = term.getSize()		
	local x,y = term.getCursorPos()
	
	local nLinesPrinted = 0
	local function newLine()
		if y + 1 <= h then
			term.setCursorPos(1, y + 1)
		else
			term.setCursorPos(1, h)
			term.scroll(1)
		end
		x, y = term.getCursorPos()
		nLinesPrinted = nLinesPrinted + 1
	end
	
	-- Print the line with proper word wrapping
	while string.len(sText) > 0 do
		local whitespace = string.match( sText, "^[ \t]+" )
		if whitespace then
			-- Print whitespace
			term.write( whitespace )
			x,y = term.getCursorPos()
			sText = string.sub( sText, string.len(whitespace) + 1 )
		end
		
		local newline = string.match( sText, "^\n" )
		if newline then
			-- Print newlines
			newLine()
			sText = string.sub( sText, 2 )
		end
		
		local text = string.match( sText, "^[^ \t\n]+" )
		if text then
			sText = string.sub( sText, string.len(text) + 1 )
			if string.len(text) > w then
				-- Print a multiline word				
				while string.len( text ) > 0 do
					if x > w then
						newLine()
					end
					term.write( text )
					text = string.sub( text, (w-x) + 2 )
					x,y = term.getCursorPos()
				end
			else
				-- Print a word normally
				if x + string.len(text) - 1 > w then
					newLine()
				end
				term.write( text )
				x,y = term.getCursorPos()
			end
		end
	end
	
	return nLinesPrinted
end

function print( ... )
	local nLinesPrinted = 0
	for n,v in ipairs( { ... } ) do
		nLinesPrinted = nLinesPrinted + write( tostring( v ) )
	end
	nLinesPrinted = nLinesPrinted + write( "\n" )
	return nLinesPrinted
end


-- Minecraft key code bindings
-- See http://www.minecraftwiki.net/wiki/Key_codes for more info

local nothing = 42
local tKeys = {
	"escape", 	"one", 		"two", 		"three", 	"four",			-- 1
	"five", 	"six", 		"seven", 	"eight", 	"nine",			-- 6
	"zero", 	"minus", 	"equals", 	"backspace","tab",			-- 11
	"q", 		"w", 		"e", 		"r",		"t",			-- 16
	"y",		"u",		"i",		"o",		"p",			-- 21
	"leftBracket","rightBracket","enter","leftCtrl","a",			-- 26
	"s",		"d",		"f",		"g",		"h",			-- 31
	"j",		"k",		"l",		"semiColon","apostrophe",	-- 36
	"grave",	"leftShift","backslash","z",		"x",			-- 41
	"c",		"v",		"b",		"n",		"m",			-- 46
	"comma",	"period",	"slash",	"rightShift","multiply",	-- 51
	"leftAlt",	"space",	"capsLock",	"f1",		"f2",			-- 56
	"f3",		"f4",		"f5",		"f6",		"f7",			-- 61
	"f8",		"f9",		"f10",		"numLock",	"scollLock",	-- 66	
	"numPad7",	"numPad8",	"numPad9",	"numPadSubtract","numPad4",	-- 71
	"numPad5",	"numPad6",	"numPadAdd","numPad1",	"numPad2",		-- 76
	"numPad3",	"numPad0",	"numPadDecimal",nil,	nil,			-- 81
	nil,	 	"f11",		"f12",		nil,		nil,			-- 86
	nil,		nil,		nil,		nil,		nil,			-- 91
	nil,		nil,		nil,		nil,		"f13",			-- 96
	"f14",		"f15",		nil,		nil,		nil,			-- 101
	nil,		nil,		nil,		nil,		nil,			-- 106
	nil,		"kana",		nil,		nil,		nil,			-- 111
	nil,		nil,		nil,		nil,		nil,			-- 116	
	"convert",	nil,		"noconvert",nil,		"yen",			-- 121
	nil,		nil,		nil,		nil,		nil,			-- 126
	nil,		nil,		nil,		nil,		nil,			-- 131
	nil,		nil,		nil,		nil,		nil,			-- 136
	"numPadEquals",nil,		nil,		"cimcumflex","at",			-- 141
	"colon",	"underscore","kanji",	"stop",		"ax",			-- 146
	nil,		"numPadEnter","rightCtrl",nil,		nil,			-- 151
	nil,		nil,		nil,		nil,		nil,			-- 156
	nil,		nil,		nil,		nil,		nil,			-- 161
	nil,		nil,		nil,		nil,		nil,			-- 166
	nil,		nil,		nil,		nil,		nil,			-- 171
	nil,		nil,		nil,		"numPadComma",nil,			-- 176
	"numPadDivide",nil,		nil,		"rightAlt",	nil,			-- 181
	nil,		nil,		nil,		nil,		nil,			-- 186
	nil,		nil,		nil,		nil,		nil,			-- 191
	nil,		"pause",	nil,		"home",		"up",			-- 196
	"pageUp",	nil,		"left",		nil,		"right",		-- 201
	nil,		"end",		"down",		"pageDown",	"insert",		-- 206
	"delete"														-- 211
}

keys = {}
for nKey, sKey in pairs( tKeys ) do
	keys[sKey] = nKey
end
keys["return"] = keys.enter

function keys.getName( _nKey )
	return tKeys[ _nKey ]
end

function read( _sReplaceChar, _tHistory )
	term.setCursorBlink( true )

    local sLine = ""
	local nHistoryPos = nil
	local nPos = 0
    if _sReplaceChar then
		_sReplaceChar = string.sub( _sReplaceChar, 1, 1 )
	end
	
	local w, h = term.getSize()
	local sx, sy = term.getCursorPos()	
	
	local function redraw( _sCustomReplaceChar )
		local nScroll = 0
		if sx + nPos >= w then
			nScroll = (sx + nPos) - w
		end
			
		term.setCursorPos( sx, sy )
		local sReplace = _sCustomReplaceChar or _sReplaceChar
		if sReplace then
			term.write( string.rep(sReplace, string.len(sLine) - nScroll) )
		else
			term.write( string.sub( sLine, nScroll + 1 ) )
		end
		term.setCursorPos( sx + nPos - nScroll, sy )
	end
	
	while true do
		local sEvent, param = os.pullEvent()
		if sEvent == "char" then
			sLine = string.sub( sLine, 1, nPos ) .. param .. string.sub( sLine, nPos + 1 )
			nPos = nPos + 1
			redraw()
			
		elseif sEvent == "key" then
		    if param == keys.enter then
				-- Enter
				break
				
			elseif param == keys.left then
				-- Left
				if nPos > 0 then
					nPos = nPos - 1
					redraw()
				end
				
			elseif param == keys.right then
				-- Right				
				if nPos < string.len(sLine) then
					nPos = nPos + 1
					redraw()
				end
			
			elseif param == keys.up or param == keys.down then
                -- Up or down
				if _tHistory then
					redraw(" ");
					if param == keys.up then
						-- Up
						if nHistoryPos == nil then
							if #_tHistory > 0 then
								nHistoryPos = #_tHistory
							end
						elseif nHistoryPos > 1 then
							nHistoryPos = nHistoryPos - 1
						end
					else
						-- Down
						if nHistoryPos == #_tHistory then
							nHistoryPos = nil
						elseif nHistoryPos ~= nil then
							nHistoryPos = nHistoryPos + 1
						end						
					end
					
					if nHistoryPos then
                    	sLine = _tHistory[nHistoryPos]
                    	nPos = string.len( sLine ) 
                    else
						sLine = ""
						nPos = 0
					end
					redraw()
                end
			elseif param == keys.backspace then
				-- Backspace
				if nPos > 0 then
					redraw(" ");
					sLine = string.sub( sLine, 1, nPos - 1 ) .. string.sub( sLine, nPos + 1 )
					nPos = nPos - 1					
					redraw()
				end
			elseif param == keys.home then
				-- Home
				nPos = 0
				redraw()		
			elseif param == keys.delete then
				if nPos < string.len(sLine) then
					redraw(" ");
					sLine = string.sub( sLine, 1, nPos ) .. string.sub( sLine, nPos + 2 )				
					redraw()
				end
			elseif param == keys["end"] then
				-- End
				nPos = string.len(sLine)
				redraw()
			end
		end
	end
	
	term.setCursorBlink( false )
	term.setCursorPos( w + 1, sy )
	print()
	
	return sLine
end
function sleep( _nTime )
    local timer = os.startTimer( _nTime )
	repeat
		local sEvent, param = os.pullEvent( "timer" )
	until param == timer
end
peripheral.wrap = function( _sSide )
	if peripheral.isPresent( _sSide ) then
		local tMethods = peripheral.getMethods( _sSide )
		local tResult = {}
		for n,sMethod in ipairs( tMethods ) do
			tResult[sMethod] = function( ... )
				return peripheral.call( _sSide, sMethod, ... )
			end
		end
		return tResult
	end
	return nil
end
if http then
	local function wrapRequest( _url, _post )
		local requestID = http.request( _url, _post )
		while true do
			local event, param1, param2 = os.pullEvent()
			if event == "http_success" and param1 == _url then
				return param2
			elseif event == "http_failure" and param1 == _url then
				return nil
			end
		end		
	end
	
	http.get = function( _url )
		return wrapRequest( _url, nil )
	end

	http.post = function( _url, _post )
		return wrapRequest( _url, _post or "" )
	end
end
--Now, before loading gets too far, if http then check for updates--
if http then
	write("Checking for updates")
	local fh = fs.open(".DSOS/update","r")
	local c = fh.readAll()
	fh.close()
	loadstring(c,"update")(version)
end
local fh = fs.open(".DSOS/newfs","r")
local newfs = loadstring(fh.readAll(),"newfs")()
fh.close()
--Safeguards--
if not fs.exists(".DSOS/part") then
	write("DSOS is broken! : Partition Directory is missing!")
	coroutine.yield("blah")
end
if not fs.exists(".DSOS/part/HDD.nfs") then
	write("DSOS is broken! : HDD Partition is missing!")
	coroutine.yield("blah")
end
local fh = fs.open(".DSOS/partition","r")
local partition = loadstring(fh.readAll(),"partition")(newfs)
fh.close()

partition.loadAll()

--Load fshelper--
local fh = fs.open(".DSOS/fshlp","r")
local fshlp = loadstring(fh.readAll(),"fshlp")(partition)
fh.close()

--Load JSON--
local fh = fs.open(".DSOS/JSON","r")
local JSON = loadstring(fh.readAll(),"JSON")()
fh.close()

--Load pipe--
local fh = fs.open(".DSOS/pipe","r")
local pipe = loadstring(fh.readAll(),"pipe")()
fh.close()

--Load task--
local fh = fs.open(".DSOS/task","r")
local task = loadstring(fh.readAll(),"task")(pipe)
fh.close()

--Load service--
local fh = fs.open(".DSOS/service","r")
local service = loadstring(fh.readAll(),"service")(task)
fh.close()

--Load sandbox--
local fh = fs.open(".DSOS/sandboxer","r")
local sandbox = loadstring(fh.readAll(),"sandboxer")()
fh.close()

--Load new fs and make copy of old fs--
local rfs = fs
local obj = fshlp.findFile("SYS","","fs")
if obj == nil then
	write("FS IS NIL")
	os.pullEvent("ioasf")
end
local fs = loadstring(obj.content,"fs")(fshlp)
write("No more primitive file loading!")
--Load api--
local fh = rfs.open(".DSOS/api","r")
local api = loadstring(fh.readAll(),"api")(fs,loadstring)
fh.close()

--[[if not fs.exists("HDD:/cfg/os") then
	fs.makeDir("HDD:/cfg/os")
	local enc = JSON:encode_pretty({SYSLOCK=true})
	local fh = fs.open("HDD:/cfg/os/sys.cfg","w")
	fh.write(enc)
	fh.close()
end
local fh = fs.open("HDD:/cfg/os/sys.cfg","r")
local syscfg = JSON:decode(fh.readAll())
fh.close()]]

--Try to load the rednet service--
local fh = fs.open("SYS:/service/rednet","r")
loadstring(fh.readAll(),"rednet")(service,api)
fh.close()

--Try to load the gps service--
local fh = fs.open("SYS:/service/gps","r")
loadstring(fh.readAll(),"gps")(service,api)
fh.close()

--Try to load the ticker service--
local fh = fs.open("SYS:/service/ticker","r")
loadstring(fh.readAll(),"ticker")(service,api,pipe)
fh.close()
service.get("Ticker").add("Hello, I'm a ticker :D")

--[[task.add(getfenv(),function()
	local pos = service.get("Position")
	local rednet = service.get("Rednet")
	rednet.open("right")
	while true do
		sleep(0)
		term.setCursorPos(1,1)
		term.clear()
		local x, y, z = pos.getPosition()
		if x ~= nil and y ~= nil and z ~= nil then
			term.write("Position: "..x..", "..y..", "..z)
		else
			term.write("Unknown Position")
		end
	end
end,"Position Note")]]

partition.flushAll()

local sandbox_extras = {fs=fs,service={get=service.get},api=api}

local fh = fs.open("SYS:/programs/shell","r")
local c, e = loadstring(fh.readAll())
fh.close()
if not c then
	error(e)
end
local w, h = term.getSize()
local pid = pipe.new(w,h-1)
sandbox_extras.term = pipe.getAPI(pid)
task.add(sandbox.new(sandbox_extras),c,"Shell")
sandbox_extras.term = nil

while true do
	task.update()
end